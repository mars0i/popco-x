(ns utils.random
  (:require [clojure.data.generators :as gen]
            [incanter.stats :as incant]
            [bigml.sampling [simple :as simple]])
  (:import [ec.util MersenneTwister MersenneTwisterFast] ; EXPERIMENTING--NEED TO DEAL WITH LICENSE NOTICES BEFORE RELEASE
           [SFMT19937])) ; EXPERIMENTING--NEED TO DEAL WITH LICENSE NOTICES BEFORE RELEASE

;; Uses clojure.core's `rand-int` method of truncation to an int with `int`
;; rather than data.generator's `uniform` method of truncation using `Math/floor`
;; followed by clojure.core's `long`.  (Why call `Math/floor` before `long`?
;; Maybe experiment with adding this before the call to `int`.)
(defn make-rand-idx-from-next-double
  "This is essentially the same as Clojure's `rand-int` with an RNG argument.
  Works with any RNG that supports `.nextDouble`, including java.util.Random,
  and Sean Luke's MersenneTwister and MersenneTwisterFast."
  [rng n]
  (int (* n (.nextDouble rng))))

(def int-range (double (- Integer/MAX_VALUE Integer/MIN_VALUE)))

;; ????
(defn make-rand-idx-from-sfmt19937
  "Supposed to work like Clojure's `rand-int`, but generated by an RNG that's
  an SFMT19937."
  [rng n]
  (int (* n                            ; When we're all done, go back to an int.
          (- (/ (.next rng) int-range) ; SFMT19937 *only* produces ints; make it into a double.
             Integer/MIN_VALUE))))     ; then make it non-negative
                                       ; Is this a good strategy??


;; Note these are lazy:

;; is "make-" correct?
;; This version repeatedly calls nth coll with a new random index each time.
(defn make-sample-with-replacement-1
  [rand-idx num-samples coll]
  (repeatedly num-samples 
              #(nth coll (rand-idx (count coll))))) ; does repeatedly make this get reevaluated every time?

;; is "make-" correct?
;; This version is inspired by Incanter, which does it like this:
;;        (map #(nth x %) (sample-uniform size :min 0 :max max-idx :integers true))
;; You get a series of random ints between 0 and the coll size,
;; and then map nth coll through them.
(defn make-sample-with-replacement-2
  [rand-idx num-samples coll]
  (map #(nth coll %) 
       (repeatedly num-samples 
                   #(rand-idx (count coll)))))


;; example:
(def sample-with-replacement
  (partial make-sample-with-replacement-1
           (partial make-rand-idx-from-next-double
                    (MersenneTwisterFast. 325117))))
