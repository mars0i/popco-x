(ns utils.random
  (:require [clojure.data.generators :as gen]
            [incanter.stats :as incant]
            [bigml.sampling [simple :as simple]])
  (:import [ec.util MersenneTwister MersenneTwisterFast] ; EXPERIMENTING--NEED TO DEAL WITH LICENSE NOTICES BEFORE RELEASE
           [SFMT19937])) ; EXPERIMENTING--NEED TO DEAL WITH LICENSE NOTICES BEFORE RELEASE

;; Uses clojure.core's `rand-int` method of truncation to an int with `int`
;; rather than data.generator's `uniform` method of truncation using `Math/floor`
;; followed by clojure.core's `long`.  (Why call `Math/floor` before `long`?
;; Maybe experiment with adding this before the call to `int`.)
(defn rand-idx-from-next-double
  "This is essentially the same as Clojure's `rand-int` with an RNG argument.
  Works with any RNG that supports `.nextDouble`, including java.util.Random,
  and Sean Luke's MersenneTwister and MersenneTwisterFast."
  [rng n]
  (int (* n (.nextDouble rng))))

(def int-range (+ 0.0 (- Integer/MAX_VALUE Integer/MIN_VALUE)))

(defn rand-idx-from-sfmt19937
  "Supposed to work like Clojure's `rand-int`, but generated by an RNG that's
  an SFMT19937."
  [rng n]
  (int (* n 
          (+ (/ (.next rng) int-range))))) ; I have no idea whether this is good


;; note these are lazy

(defn make-sample-with-replacement-1
  [rand-idx num-samples coll]
  (repeatedly num-samples 
              #(nth coll (partial rand-idx (count coll))))) ; does repeatedly make this get reevaluated every time?

;; This version is inspired by Incanter, which does it like this:
;;        (map #(nth x %) (sample-uniform size :min 0 :max max-idx :integers true))
(defn make-sample-with-replacement-2
  [rand-idx num-samples coll]
  (map #(nth x %) 
       (repeatedly num-samples 
                   (partial rand-idx (count coll)))))


;; example:
(def sample-with-replacement
  (partial make-sample-with-replacement-1
           (partial rand-idx-from-next-double
                    (MersenneTwisterFast. 325.117))))
