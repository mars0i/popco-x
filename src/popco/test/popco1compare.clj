(ns popco.test.popco1compare
  (:use ;[popco.nn.nets :as nn]
        ;[clojure.pprint :only [cl-format]]
        [popco.nn.pprint :as pp]
        [utils.general :as ug])
  ;(:require [clojure.core.matrix :as mx]
  ;          [clojure.string :as string])
)

(declare sorted-links-for-popco1-comparison list-links-for-popco1-comparison upper-case-link
         matched-links same-nodes? same-weights?)

(defn sorted-links-for-popco1-comparison
  "Generates an alphabetically sorted sequence of links in a form useful for 
  comparison with output of popco1's list-constraints-for-popco2-comparison 
  function.  Links have the form generated by list-links-for-popco-comparison.
  Example usage:
  (pprint (sorted-links-for-popco1-comparison a) (clojure.java.io/writer \"yo.txt\"))"
  [nnstru]
  (sort pp/compare-links
        (list-links-for-popco1-comparison nnstru)))

(defn list-links-for-popco1-comparison
  "Generates a sequence of links in a form useful for comparison with output
  of popco1's list-constraints-for-popco2-comparison function.  Link 
  reprsentations have the form generated by popco.nn.pprint/list-links, but 
  links are also normalized: ids uppercased, with the two ids alpha ordered 
  within each link representation.  Example usage:
  (pprint (list-links-for-popco1-comparison a) (clojure.java.io/writer \"yo.txt\"))"
  [nnstru]
  (map (comp pp/normalize-link upper-case-link)
       (pp/list-links nnstru)))

(defn upper-case-link
  "Given a representation of a link as 
     [node-id-keyword node-id-keyword weight]
  returns a represention that's similar, but with uppercased keyword names."
  [[id1 id2 wt1 wt2]]
  [(ug/upper-case-keyword id1) (ug/upper-case-keyword id2) wt1 wt2])

(defn same-nodes?
  [[id1a id1b] [id2a id2b]]   ; ignores additional elements within each argument
  (and (identical? id1a id2a)
       (identical? id1b id2b)))

(defn same-weights?
  [[_ _ wt1a wt1b][_ _ wt2a wt2b]]
  (and (== wt1a wt2a)
       (== wt1b wt2b)))

;; inefficient but fast enough for its use case
(defn matched-links
  "Given two seqs of links in list-links format, generate a sequence of pairs
  of links that have the same node ids.  Weights need not be the same.  Assumes
  that links have been normalized as by popco.nn.pprint/normalize-link, i.e. 
  within each link representation, the two ids are in alpha order, but links do
  not have to be sorted within each of the two toplevel seqs.  Unmatched links
  are simply ignored."
  [links1 links2]
  (for [lk1 links1
        lk2 links2]
    (list lk1 lk2)))

;; **********
;; **********
;; CONSIDER USING clojure.data/diff for the following
;; **********
;; **********
;; FUNCTION TO RETURN BOTH MATCHED PAIRS AND UNMATCHED INDIVIDUAL LINKS, DIVIDED BY
;; SOURCE.  FIRST ATTEMPT INCOMPLETE AND NOT RIGHT ANYWAY:
;(defn matched-and-unmatched-links
;  [links1 links2]
;  (cond 
;    (or (empty? links1) (empty? links2))
;    [nil (concat links1 links2)]  ; if either is non-empty, we want it as second value
;
;    (same-nodes? (first links1) (first links2))
;    (let [[matched unmatched] (recur (rest links1) (rest links2))] ; won't work--not tail call
;        [(cons [(first links1) (first links2)] matched) unmatched]))
;  ;; unfinished
;  )

