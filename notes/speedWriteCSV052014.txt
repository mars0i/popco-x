5/3/2014
popco2
git hist id 96a28b4
Comparison of popco.io.csv/write-propn-activns-csv with and without doall'ing its input.

project.clj:
   :jvm-opts ["-Xmx3g" "-Dclojure.compiler.disable-locals-clearing=true"] 
for the 1000-tick runs.
I think I had it lower--1g or 2g for the 100-tick runs.

Note:
;; I BELIEVE that write-propn-activns-csv roughly writes line by line, similar to write-propn-activns-csv-by-line.
;; This is explicity in the latter, since it doseq's through the ticks, writing a line
;; each time.  But in the spit version:
;; (a) spit-csv uses write-csv
;; (b) write-csv uses write-csv* which uses loop/recur to go through the rows: https://github.com/clojure/data.csv/blob/b70b33d56c239972f3e1c53c3c4f1b786909e93f/src/main/clojure/clojure/data/csv.clj#L123
;; (c) I use map to iterate through ticks, i.e. lazily
;;     (also propn-activns-row uses mapcat to put together data from persons in a tick, which is lazy)
;; So it's only at when write-csv* loops through the rows that the ticks are realized.
;; So that even though it looks like write-propn-activns-csv collects all of the data at once before writing it, it doesn't.

-------------------
SUMMARY

1. doall'ing the tick-populations is about 20-25% faster.  

However, this is true *only* if you allocate a lot of RAM to the jvm
with -Xmx.  I'd previously found that if you don't do that, with 'doall'
the ticks eventually start going very slowly, and/or the process runs
out of memory and ends before you're done.  In this case, for the
1000-tick runs I gave 'java' -Xmx3g, i.e. 3 gigabytes max heap, which,
experimentally, I had decided was a good number.  And it used all of it.
The final size of java reported by Activity Monitor in the 1000-tick was
3.19GB.  The size of java when it was just running the no-doall, lazy version
was about 500MB. However, it was that high only because of some previous
experiments I'd done in the same REPL.  By itself, 1000 ticks with lazy
evaluation and no head preservation, etc., pushes the java process size
to only about 280MB.

Moreover, this 20-25% is on a process that takes on the order of one
minute, and should be about 6 minutes vs. 5 minutes for 5000 ticks 500
ticks would presumably need about 15GB to use 'doall'.  Doesn't seem
worth it.  Even if, say, I'm running 100 duplicate runs, and Cheaha runs
25 at a time, that's less than a 5 minute difference if I'm doing as
many as 5000 ticks, and if Cheaha will let me run that many 15GB
processes at once.

So: I'm inclined to do without the extra speed of the 'doall', in
general.  It's easy to add when it seems appropriate.
(This means that I can keep my usual heap size a lot lower.)


2. 1000 ticks takes 8 to 8.5 times longer than 100 ticks (rather than 10
times, as you might have expected).


-------------------
100 ticks:

;; Note the two calls are the same except for 'doall' inserted in the second one:
popco.core.popco=> (do (bench (def _ (csv/write-propn-activns-csv (take 100 (many-times popn))))) (bench (def _ (csv/write-propn-activns-csv (doall (take 100 (many-times popn)))))))
WARNING: Final GC required 4.950079029146208 % of runtime
Evaluation count : 60 in 60 samples of 1 calls.
             Execution time mean : 8.763114 sec
    Execution time std-deviation : 116.040109 ms
   Execution time lower quantile : 8.541575 sec ( 2.5%)
   Execution time upper quantile : 8.914888 sec (97.5%)
                   Overhead used : 2.462255 ns

Found 1 outliers in 60 samples (1.6667 %)
	low-severe	 1 (1.6667 %)
 Variance from outliers : 1.6389 % Variance is slightly inflated by outliers
Evaluation count : 60 in 60 samples of 1 calls.
             Execution time mean : 7.307305 sec
    Execution time std-deviation : 58.589712 ms
   Execution time lower quantile : 7.204453 sec ( 2.5%)
   Execution time upper quantile : 7.401399 sec (97.5%)
                   Overhead used : 2.462255 ns
nil

Ratio between first (lazy) and second (doall) version above:
popco.core.popco=> (/ 8.763114 7.307305)
1.1992265274270062

-------------------
1000 ticks

;; Note the two calls are the same except for 'doall' inserted in the second one:
popco.core.popco=> (do (bench (def _ (csv/write-propn-activns-csv (take 1000 (many-times popn))))) (bench (def _ (csv/write-propn-activns-csv (doall (take 1000 (many-times popn)))))))
Evaluation count : 60 in 60 samples of 1 calls.
             Execution time mean : 1.185494 min
    Execution time std-deviation : 1.128564 sec
   Execution time lower quantile : 1.157907 min ( 2.5%)
   Execution time upper quantile : 1.222079 min (97.5%)
                   Overhead used : 2.462255 ns

Found 1 outliers in 60 samples (1.6667 %)
	low-severe	 1 (1.6667 %)
 Variance from outliers : 1.6389 % Variance is slightly inflated by outliers
Evaluation count : 60 in 60 samples of 1 calls.
             Execution time mean : 1.051464 min
    Execution time std-deviation : 391.380810 ms
   Execution time lower quantile : 1.037670 min ( 2.5%)
   Execution time upper quantile : 1.062598 min (97.5%)
                   Overhead used : 2.462255 ns
nil

Ratio between first (lazy) and second (doall) version above:
popco.core.popco=> (/ 1.185494 1.051464)
1.127469889601546

-------------------
Comparison of 1000 ticks vs 100 ticks:

lazy:
popco.core.popco=> (/ (* 1.185494 60) 8.763114)
8.11693651366398

doall'ed:
popco.core.popco=> (/ (* 1.051464 60) 7.307305)
8.63353041921748
