Change in 3rd column, etc. of activns.csv introduced before or at:
489094e 2014-05-10 | Finished converting all numbers to Ratio [mabrams]
and after:
1296d4e 2014-05-09 | Revisions to for optional use of ratios or BigDecimals. [mabrams]
(SUBSEQUENTLY FIXED 5/12/2014 IN a34074a.)

These are adjacent.  Here is their diff:

diff --git a/src/popco/core/person.clj b/src/popco/core/person.clj
index 5e08e04..22c8dc4 100644
--- a/src/popco/core/person.clj
+++ b/src/popco/core/person.clj
@@ -1,6 +1,6 @@
 (ns popco.core.person
   (:require [utils.general :as ug]
-            [popco.core.communic :as cc]
+            [popco.core.communic :as cm]
             [popco.core.constants :as cn]
             [popco.nn.nets :as nn]
             [popco.nn.propn :as pn]
@@ -56,8 +56,8 @@
     (nn/unmask!     (:analogy-mask pers) ((:id-to-idx analogy-net) :SEMANTIC))
     (nn/set-activn! (:analogy-activns pers) ((:id-to-idx analogy-net) :SEMANTIC) cn/+one+) ; semantic node always has activn = 1
     (nn/set-mask!   (:analogy-mask pers) ((:id-to-idx analogy-net) :SEMANTIC) (/ cn/+one+ cn/+decay+)) ; Kludge to undo next-activn's decay on this node
-    (doseq [propn-id propn-ids] (cc/add-to-propn-net! pers propn-id))   ; better to fill propn mask before
-    (doseq [propn-id propn-ids] (cc/try-add-to-analogy-net! pers propn-id)) ;  analogy mask, so propns are known
+    (doseq [propn-id propn-ids] (cm/add-to-propn-net! pers propn-id))   ; better to fill propn mask before
+    (doseq [propn-id propn-ids] (cm/try-add-to-analogy-net! pers propn-id)) ;  analogy mask, so propns are known
     pers))
 
 (defn clone
@@ -120,6 +120,6 @@
 ;                        analogy-net
 ;                        (mx/zero-vector num-poss-analogy-nodes)   ; analogy-mask
 ;                        (mx/zero-vector num-poss-analogy-nodes))] ; analogy-activns
-;     (doseq [propn propns] (cc/add-to-propn-net pers (:id propn)))   ; better to fill propn mask before
-;     (doseq [propn propns] (cc/old-add-to-analogy-net pers (:id propn))) ;  analogy mask, so propns are known
+;     (doseq [propn propns] (cm/add-to-propn-net pers (:id propn)))   ; better to fill propn mask before
+;     (doseq [propn propns] (cm/old-add-to-analogy-net pers (:id propn))) ;  analogy mask, so propns are known
 ;     pers))
diff --git a/src/popco/nn/analogy.clj b/src/popco/nn/analogy.clj
index aa73438..05c0a19 100644
--- a/src/popco/nn/analogy.clj
+++ b/src/popco/nn/analogy.clj
@@ -379,7 +379,7 @@
   to the same predicate.  1.0 is the multiplier for semantic links to such nodes,
   since identical predicates represent the highest possible semantic similarity."
   [node-seq id-to-idx]
-  (map #(vector 1.0 %)
+  (map #(vector cn/+one+ %)
        (map (comp id-to-idx :id) 
             (filter dupe-pred-mapnode? node-seq))))
 
diff --git a/src/popco/nn/nets.clj b/src/popco/nn/nets.clj
index 7581f2b..87702f3 100644
--- a/src/popco/nn/nets.clj
+++ b/src/popco/nn/nets.clj
@@ -1,6 +1,7 @@
 (ns popco.nn.nets
   (:require [utils.general :as ug]
             [popco.core.lot :as lot]
+            [popco.core.constants :as cn]
             [clojure.core.matrix :as mx]))
 
 ;; Definitions of neural-net data types and related functions.
@@ -86,12 +87,12 @@
 (defn posify 
   "Return the non-negative number closest to x, i.e. 0 if x < 0, else x."
   [x]
-  (max 0 x))
+  (max cn/+zero+ x))
 
 (defn negify
   "Return the non-positive number closest to x, i.e. 0 if x > 0, else x."
   [x]
-  (min 0 x))
+  (min cn/+zero+ x))
 
 (defn make-id-to-idx-map
   "Given a sequence of things, returns a map from things to indexes.  
@@ -142,21 +143,21 @@
   "Given a core.matrix vector representing a mask, and an index
   into the mask, set the indexed element of the mask to 1."
   [mask idx]
-  (set-mask! mask idx 1.0))
+  (set-mask! mask idx cn/+one+))
 
 (defn node-unmasked?
   "Given a core.matrix vector representing a mask, and an index
   into the mask, return true if the mask is 1 at that index;
   otherwise false."
   [mask idx]
-  (= 1.0 (mx/mget mask idx)))
+  (= cn/+one+ (mx/mget mask idx)))
 
 (defn node-masked?
   "Given a core.matrix vector representing a mask, and an index
   into the mask, return true if the mask is 0 at that index;
   otherwise false."
   [mask idx]
-  (= 0.0 (mx/mget mask idx)))
+  (= cn/+zero+ (mx/mget mask idx)))
 
 (defn mask-matrix
   "Given a weight matrix and a mask vector (1-dimensional, i.e. not a 1xN row 
diff --git a/src/sims/crime3/example99.clj b/src/sims/crime3/example99.clj
index 60b4c7f..55299e8 100644
--- a/src/sims/crime3/example99.clj
+++ b/src/sims/crime3/example99.clj
@@ -3,7 +3,6 @@
             [popco.nn.propn :as pn]
             [popco.core.person :as pers]
             [popco.core.population :as pp]
-            [popco.core.main :as mn]
             [popco.core.constants :as cn]
             [sims.crime3.propns :as pns]))
 
diff --git a/src/sims/crime3/propns.clj b/src/sims/crime3/propns.clj
index ea88729..5934dd2 100644
--- a/src/sims/crime3/propns.clj
+++ b/src/sims/crime3/propns.clj
@@ -1,6 +1,6 @@
 (ns sims.crime3.propns
-  [:use popco.core.lot]
-  [:import [popco.core.lot Propn Pred Obj]])
+  (:use popco.core.lot)
+  (:require [popco.core.constants :as cn]))
 
 ;; declare all proposition names
 ;(declare V-ip V-na V-ia V-ha V-ia->v-ha V-ipa V-ipa->v-ia V-ica V-ica->-v-ipa V-ica->-v-ipa->v-na V-qp V-qp->-v-ipa V-qp->-v-ipa->v-na
@@ -126,9 +126,9 @@
 ;    (semantic-iff 'cv-rpa 'b-abp -.1L0)
 ;   ))
 
-(def semantic-iffs [[-0.1 :CB-vpp :V-ipa] [-0.1 :CV-rpa :B-abp]])
+(def semantic-iffs [[cn/+neg-one+ :CB-vpp :V-ipa] [cn/+neg-one+ :CV-rpa :B-abp]])
 
-(def conceptual-relats [[-1.0 :Causal-if :Preventative-if]])
+(def conceptual-relats [[cn/+neg-one+ :Causal-if :Preventative-if]])
 ;; This specifies mapnodes that should be provided with a link from SEMANTIC.
 ;; Note order of the last two arguments doesn't matter: Both orders are tried.
 ;; The number will be multiplied by the default semantic link weight of
