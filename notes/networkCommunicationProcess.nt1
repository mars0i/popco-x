Global parameters of a run:

	master analogy net

	master vector of propns
		this is easy
		e.g. in crime3propns.clj, it's all-propns, defined at the end of the file
		well, maybe it should be converted from a LazySeq to a vector.

We have to provide to each person:

	a mask on mapnode indexes for the analogy net

	a mask on propn indexes for the propn net
		this is going to require mapping from propns to mapnodes (?)

	a propn net

How are the masks used?  

	For reporting of what nodes exist in a person's two networks

	During network settling, on each iteration, the activation vector which is the output
	of the Grossberg algorithm should be element-multiplied by the mask, zeroing out
	activations in nodes that are not supposed to exist in that person.  (i.e. it's innocuous
	to allow activation to flow through the network to nodes that don't exist in the person,
	since there's no distribution of the total activation in the source node going on.
	We can allow the multiplication to send activation to "non-existent" nodes, but then
	just zero them before the next iteration so that they won't affect other nodes.)

When you add a new propn to a receipient person due to communication (or
direct intervention by the modeler), the following has to happen:

	The proposition P has to be unmasked in the propn mask.

	Any relevant map nodes that are masked have to be unmasked.
	This is a little bit tricky.  What has to be unmasked is:

		1. Any propositional map node that has P on one side, where
		the other side already exists in the recipient person.
		Note that for this purpose it helps to identify which
		analogue P is in.

		2. Any predicate or object map node that are related by
		component relations to the new propositional map node,
		if they don't exist already (and they might).

		3. Any propositional map node that's related by component
		relations through the argument place in the new proposition.
		This could cause recursing back through step 2.
		[Is this correct?]

The point of having a mapping from propns to mapnodes would be so that
when you add a propn a new to a person, you could figure out efficiently
what other map nodes to unmask.  Um, but maybe it's more complicated
than that?

OK, how about for each propn, generate an vec of indexes of mapnodes
that it would cause to come into existence.  This might be best
generated at the same time that I'm generating the map nodes?  Then make
a Clojure map from propn to such vecs of indexes.  Then when you receive
a new proposition, just check whether those nodes exist or not, and pop
them into existence if not (or just do it and don't worry if they're
already there.)
Yes, like that: But don't use a Clojure map to connect propns to vecs of
indexes of mapnodes:

Just have a Clojure vector with the slot for each propn containing a
vector of mapnode indexes.  Just identify propns by their indexes in the
master vec, which is also their indexes wrt the propn net.  And when
communicating, just pass a propn index and an activn.  Is that
significantly faster?  Than using a map with propns?

[Note that while propns that are args are matched, just by that very
fact, their args are not matched by that fact (but they'll get matched
anyway, I think).]

Uh, that's not quite right.  There's a two-step process for new propns:

1. check whether there are any propn-mapnodes with this as one side,
and an existing propn as the other side.

2. Find associated component mapnodes.

So you really need a way of getting from propn mapnodes to the others, for step 2.
(But I don't think that can be done with a vector, without using a clojuremap.
propn mapnodes per se don't have their own vector.  Only propns, and all mapnodes,
have that.)

And for step 1, you need something else.

(umm, this is starting to worry me that it's too fragile)


;; TODO NOTE ON CONSTRUCTING SOMETHING THAT ALLOWS FINDING ALL MAPNODES DERIVED FROM A PROPN-MAPNODE:
;; How about if we pass p1 and p2 above, or their mapnode, to the other mapnodes, and add that info
;; to an additional field in the sorted-map that represents the mapnode?
;;
;; PROBLEM: Duplicate mapnodes are created in this process.  I squash them out later using 'distinct'
;; in make-analogy-net.  So we'd need an additional pass to merge the associated data, rather than
;; or in addition to using distinct.  Also, this is associating the propns with the component nodes,
;; when what I really want is the reverse.  So would need a *further* pass to reverse the relationship.
;;
;; Note that the relationship between propn-mapnodes and other mapnodes is many-to-many:
;; Each propn-mapnode has a predicate-mapnode and zero or more arg-mapnodes (either obj-mapnodes
;; or propn-mapnodes).
;; But a predicate-mapnode can be related to more than one propn-mapnode, and likewise for
;; arg-mapnodes.
;;
;; OK, so how about if I make the component mapnodes first, above, and then stuff info about them
;; into the propn-mapnode?
;;
;; Or better yet, make them, and then *also* put them into a Clojure map from propn pairs (or a mapnode)
;; to the associated info.  But make it so that updating this map just conses into the value, rather
;; than replacing it.  (Later this clojure-map has to be made in a vector, probably.)
;; And then ... Return a pair, where one element is the seq of mapnodes, and the other is the "map"
;; from propn-mapnodes to component mapnodes?
;;
;; OHH ... Here is some trickyness:
;;
;; (a) If personA communicates propn1 to personB, and propn1 has propn2 as an arg, then is it
;;     as if propn2 has been communicated as well?  (WHAT DID POPCO DO?  (What should it have done?))
;;
;;     In that case, in order to decide whether to add mapnodes in personB, do *both* at leat one of
;;     propn1's analogues *and* the corresponding analogue of propn2 have to already exist in personB 
;;     before we start adding mapnodes??
;;
;; (b) What if personA first communicates propn2 to personB?  If personB has an analogue of propn2,
;;     is that enough for adding mapnodes?  Or must personB also have propn1's analogues?
;;     OK, the answer to the last question is clearly "no".  But I must be careful that the
;;     method of looking up mapnodes as a result of communication reflects this answer.
;;     i.e. the entry for mapnodes involving propn2 should not reference propn1.
;;     (POPCO/POPCO-X don't handle mutual recursion of propns, btw.)

How to implement that?  Doing it as before with map isn't working.  I think I need something
fancier like for.
