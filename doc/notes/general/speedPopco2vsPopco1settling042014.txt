TIME TRIALS WITH NET UPDATES ONLY, NO COMMUNICATION, LATE APRIL 2014

===================================================
SUMMARY ON MY MBP

popco2: 
The `time` tests are in line with the Criterium tests, so I'll use the former.

many-times for 1000 ticks took 143.2 secs, or 2.39 minutes.
many-times! for 1000 ticks took 139.1 secs, or 2.32 minutes.

(And for 5000 ticks, that would be about

popco1:
Took 1209.76 seconds, or 20.16 minutes.

summary:
Yayy!  popco2 is *lots* faster.  More than 8X faster.
For 5000 ticks, that would be 12 minutes for popco2 ... vs 1hr 40 mins for popco1.
Yes!

many-times takes about 1.03 as long as many-times!, i.e. 3% slower.
(This is more costly than I expected based on a test in isolation from
the application itself.  3% advantage might be worth keeping, if it ads
up, with other optimizations.  On the other hand, the overall speed is
*so* much faster than popco2, that for now, I'm going with the
functional version.)

===================================================
SUMMARY ON MBA:

popco2 is 10X faster than popco1, using map.
and pmap is about 70% of the map time.

===================================================
POPCO-X/POPCO2 ON MBP:
With git hist marker 1b7efd8 and crime3/example99.clj:

33 both-biasers job, 33 virus-biasers jov, and 33 beast-biaser job.
Criterium test for 100 ticks,
raw time test for 1000 ticks.

popco.core.popco=> (criterium.core/bench (def popn100 (nth (many-times popn) 100)))
Evaluation count : 60 in 60 samples of 1 calls.
             Execution time mean : 14.406778 sec
    Execution time std-deviation : 127.900578 ms
   Execution time lower quantile : 14.264241 sec ( 2.5%)
   Execution time upper quantile : 14.757114 sec (97.5%)
                   Overhead used : 2.520170 ns

Found 23 outliers in 60 samples (38.3333 %)
	low-severe	 10 (16.6667 %)
	low-mild	 5 (8.3333 %)
	high-mild	 8 (13.3333 %)
 Variance from outliers : 1.6389 % Variance is slightly inflated by outliers


popco.core.popco=> (criterium.core/bench (def popn100 (nth (many-times! popn) 100)))
popco.core.popco=> (criterium.core/bench (def popn100bang (nth (many-times! popn) 100)))
Evaluation count : 60 in 60 samples of 1 calls.
             Execution time mean : 13.868870 sec
    Execution time std-deviation : 18.845807 ms
   Execution time lower quantile : 13.839931 sec ( 2.5%)
   Execution time upper quantile : 13.914262 sec (97.5%)
                   Overhead used : 2.520170 ns

Found 2 outliers in 60 samples (3.3333 %)
	low-severe	 2 (3.3333 %)
 Variance from outliers : 1.6389 % Variance is slightly inflated by outliers


popco.core.popco=> (time (def popn100 (nth (many-times popn) 1000))) (time (def popn100bang (nth (many-times! popn) 1000)))
"Elapsed time: 143202.883 msecs"
#'popco.core.popco/popn100
"Elapsed time: 139076.414 msecs"
#'popco.core.popco/popn100bang
popco.core.popco=> (/ 143202.883 139076.414)
1.0296705162386486
popco.core.popco=> (/ 143202.883 (* 60 1000))
2.386714716666667
popco.core.popco=> (* 5 (/ 143202.883 (* 60 1000)))
11.933573583333335
popco.core.popco=> (/ 139076.414  (* 60 1000))
2.317940233333333
popco.core.popco=> (* 5 (/ 139076.414  (* 60 1000)))
11.589701166666666


Also, here's Criterium on 1000 ticks with many-times!:

popco.core.popco=> (criterium.core/bench (def popn1000 (nth (many-times! popn) 1000)))
WARNING: Final GC required 4.68358962442443 % of runtime
Evaluation count : 60 in 60 samples of 1 calls.
             Execution time mean : 2.357626 min
    Execution time std-deviation : 51.445795 ms
   Execution time lower quantile : 2.355941 min ( 2.5%)
   Execution time upper quantile : 2.359315 min (97.5%)
                   Overhead used : 2.417913 ns
nil

===================================================
PMAP ON MBP

Replacing `map` with `pmap` in popco.nn.update/update-nets produces this:

popco.core.popco=> (time (def popn1000bang (nth (many-times popn) 1000)))
"Elapsed time: 59307.667 msecs"

That's 1 minute for 1000 ticks!

popco.core.popco=> (time (def popn5000bang (nth (many-times popn) 5000)))
"Elapsed time: 307048.772 msecs"
#'popco.core.popco/popn5000bang
popco.core.popco=> (/ 307.048772 60)
5.117479533333333

And 5 minutes for 5000 ticks.

CPU usage goes to about 540% during this process.

(Obviously this doesn't help with running multiple simulations.
Unless the cheaha folks will let me take over the whole cluster....
But for experimenting, at least ... it's incredible.)

===================================================
POPCO 1 ON MBP:

4/25/2014 with crime/crime3example99.lisp
33 both-biasers job, 33 virus-biasers jov, and 33 beast-biaser job:

* (time (popco*))

Running popco with maximum of 5 cycles each in 1000 popco tick(s) ....
*do-converse* NIL; *do-update-propn-nets-from-analogy-nets* T; *do-report-to-netlogo* NIL; *do-report-propns-to-csv* NIL; *use-new-random-state* T
1000
Evaluation took:
  1212.021 seconds of real time
  1209.760389 seconds of total run time (1200.559819 user, 9.200570 system)
  [ Run times consist of 70.328 seconds GC time, and 1139.433 seconds non-GC time. ]
  99.81% CPU
  2,787,712,278,274 processor cycles
  1 page fault
  526,989,941,696 bytes consed

===================================================
OTHER NOTES RE MBP

I tried it with ndarray.  Very slow.
63039.313 milliseconds *for 5 ticks*.
That's 3.5 hours for 1000 ticks.

I tried it with clatrix, but it won't work because at present,
core.matrix treats clatrix matrices as immutable, because not all
mutation ops are supported yet.  (But the underlying matrices
*are* mutable.)

===================================================
POPCO2 ON MBA, INCLUDING PMAP:

Summary of `time` results for 1000 ticks, with 99 persons:

many-times:     5.18 mins
many-times!:    5.02 mins
(again, only 3% difference between the purely functional mutational versions)
pll-many-times: 3.6 mins (i.e. with pmap)
(So even on the 4-core (?) MBA, pmap makes a significant difference)

Details:

popco.core.popco=> (time (def yo1000 (nth (many-times popn) 1000)))
"Elapsed time: 310577.721 msecs"
#'popco.core.popco/yo1000
popco.core.popco=> (/ 310.577721 60)
5.17629535

popco.core.popco=> (time (def yo1000pll (nth (pll-many-times popn) 1000)))
"Elapsed time: 214108.734 msecs"
#'popco.core.popco/yo1000pll
popco.core.popco=> (/ 214.108734 60)
3.5684789

popco.core.popco=> (time (def yo1000bang (nth (many-times! popn) 1000)))
"Elapsed time: 301165.998 msecs"
#'popco.core.popco/yo1000bang
popco.core.popco=> (/ 301.165998 60)
5.0194333

popco.core.popco=> (/ 5.17629535 5.0194333)
1.031250948189709

FOR POPCO1:

Running popco with maximum of 5 cycles each in 1000 popco tick(s) ....
*do-converse* NIL; *do-update-propn-nets-from-analogy-nets* T; *do-report-to-netlogo* NIL; *do-report-propns-to-csv* NIL; *use-new-random-state* T
1000
Evaluation took:
  2993.756 seconds of real time
  2983.515941 seconds of total run time (2959.288025 user, 24.227916 system)
  [ Run times consist of 184.258 seconds GC time, and 2799.258 seconds non-GC time. ]
  99.66% CPU
  4,777,980,534,672 processor cycles
  5 page faults
  526,990,014,960 bytes consed
  
T
* (/ 2993.756 60)

49.895935
