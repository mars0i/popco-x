Global parameters of a run:

	master analogy net

	master vector of propns
		this is easy
		e.g. in crime3propns.clj, it's all-propns, defined
		at the end of the file
		well, maybe it should be converted from a LazySeq to a vector.

We have to provide to each person:

	a mask on mapnode indexes for the analogy net

	a mask on propn indexes for the propn net
		this is going to require mapping from propns to mapnodes (?)

	a propn net

How are the masks used?  

	For reporting of what nodes exist in a person's two networks

	During network settling, on each iteration, the activation
	vector which is the output of the Grossberg algorithm should be
	element-multiplied by the mask, zeroing out activations in nodes
	that are not supposed to exist in that person.  (i.e. it's
	innocuous to allow activation to flow through the network to
	nodes that don't exist in the person, since there's no
	distribution of the total activation in the source node going
	on.  We can allow the multiplication to send activation to
	"non-existent" nodes, but then just zero them before the next
	iteration so that they won't affect other nodes.)

When you add a new propn to a receipient person due to communication (or
direct intervention by the modeler), the following has to happen:

	The proposition P has to be unmasked in the propn mask.

	Any relevant map nodes that are masked have to be unmasked.
	This is a little bit tricky.  What has to be unmasked is:

		1. Any propositional map node that has P on one side, where
		the other side already exists in the recipient person.
		Note that for this purpose it helps to identify which
		analogue P is in.

		2. Any predicate or object map node that are related by
		component relations to the new propositional map node,
		if they don't exist already (and they might).

		3. Any propositional map node that's related by component
		relations through the argument place in the new proposition.
		This could cause recursing back through step 2.
		[Is this correct?]

The point of having a mapping from propns to mapnodes would be so that
when you add a propn a new to a person, you could figure out efficiently
what other map nodes to unmask.  Um, but maybe it's more complicated
than that?

OK, how about for each propn, generate an vec of indexes of mapnodes
that it would cause to come into existence.  This might be best
generated at the same time that I'm generating the map nodes?  Then make
a Clojure map from propn to such vecs of indexes.  Then when you receive
a new proposition, just check whether those nodes exist or not, and pop
them into existence if not (or just do it and don't worry if they're
already there.)
Yes, like that: But don't use a Clojure map to connect propns to vecs of
indexes of mapnodes:

Just have a Clojure vector with the slot for each propn containing a
vector of mapnode indexes.  Just identify propns by their indexes in the
master vec, which is also their indexes wrt the propn net.  And when
communicating, just pass a propn index and an activn.  Is that
significantly faster?  Than using a map with propns?

[Note that while propns that are args are matched, just by that very
fact, their args are not matched by that fact (but they'll get matched
anyway, I think).]

Uh, that's not quite right.  There's a two-step process for new propns:

1. check whether there are any propn-mapnodes with this as one side,
and an existing propn as the other side.

2. Find associated component mapnodes.

	This can be a map from propn mapnode ids to associated indexes
	(including the propn mapnode's id), since that's what you need
	at the receiver end: You need to unmask those ids.  Or you could
	have a vector, mapping from propn mapnode indexes, but probably
	doesn't matter, and ids are clearer.

So you really need a way of getting from propn mapnodes to the others,
for step 2.  (But I don't think that can be done with a vector, without
using a clojuremap.  propn mapnodes per se don't have their own vector.
Only propns, and all mapnodes, have that.)

And for step 1, you need something else.

(umm, this is starting to worry me that it's too fragile)

   TODO NOTE ON CONSTRUCTING SOMETHING THAT ALLOWS FINDING ALL MAPNODES
   DERIVED FROM A PROPN-MAPNODE: How about if we pass p1 and p2 above,
   or their mapnode, to the other mapnodes, and add that info to an
   additional field in the sorted-map that represents the mapnode?

   PROBLEM: Duplicate mapnodes are created in this process.  I squash
   them out later using 'distinct' in make-analogy-net.  So we'd need an
   additional pass to merge the associated data, rather than or in
   addition to using distinct.  Also, this is associating the propns
   with the component nodes, when what I really want is the reverse.  So
   would need a *further* pass to reverse the relationship.

   Note that the relationship between propn-mapnodes and other mapnodes
   is many-to-many: Each propn-mapnode has a predicate-mapnode and zero
   or more arg-mapnodes (either obj-mapnodes or propn-mapnodes).  But a
   predicate-mapnode can be related to more than one propn-mapnode, and
   likewise for arg-mapnodes.

   OK, so how about if I make the component mapnodes first, above, and
   then stuff info about them into the propn-mapnode?

   Or better yet, make them, and then *also* put them into a Clojure map
   from propn pairs (or a mapnode) to the associated info.  But make it
   so that updating this map just conses into the value, rather than
   replacing it.  (Later this clojure-map has to be made in a vector,
   probably.) And then ... Return a pair, where one element is the seq
   of mapnodes, and the other is the "map" from propn-mapnodes to
   component mapnodes?

   OHH ... Here is some trickyness:

   (a) If personA communicates propn1 to personB, and propn1 has propn2
       as an arg, then is it as if propn2 has been communicated as well?
       (WHAT DID POPCO DO?  (What should it have done?))

       In that case, in order to decide whether to add mapnodes in
       personB, do *both* at leat one of propn1's analogues *and* the
       corresponding analogue of propn2 have to already exist in personB
       before we start adding mapnodes??

   (b) What if personA first communicates propn2 to personB?  If personB
       has an analogue of propn2, is that enough for adding mapnodes?
       Or must personB also have propn1's analogues?  OK, the answer to
       the last question is clearly "no".  But I must be careful that
       the method of looking up mapnodes as a result of communication
       reflects this answer.  i.e. the entry for mapnodes involving
       propn2 should not reference propn1.  (POPCO/POPCO-X don't handle
       mutual recursion of propns, btw.)

How to implement that?  Doing it as before with map isn't working.  I think I need something
fancier like for.

Or maybe not: What match-propn-components returns is a seq of seqs in which the first element
of the subseq is always a propn mapnode, and the rest are the component mapnode.
New function seq-to-map-of-set ought to be useful.

---------------
What POPCO does:

receive-utterance (in popco.lisp, called indirectly from
transmit-utterances) simply tests whether the received propn is already
there.  No checking of argument propns.  If it's new to the receiver,
it's added to the appropriate analog structure, then given an activation
value (i.e. in the propn net), and we check whether there are any
semantic-iffs for it and set up the links for them if so (also wrt the
propn net).

So the incorporation into the analogy net comes at a later stage of the
main loop, update-analogy nets, which indirectly calls
make-constraint-net in acme.lisp, the normal all-encompassing analogy
net maker/updater.  And that just does what it normally does--what it
does when first creating the analogy net.  It makes mapnodes if
necessary, creates their links, etc.

So the answer to question (a) above appears to be:

1. As far as the propn net is concerned: No, the argument proposition is
not communicated.

2. As far as the analogy net is concerned, it's as if the argument propn
is communicated.  Because make-constraint-net is going to look at the
entire structure of the propn sent (propn1), and its arg propn2 will
play the normal role in analogy net creation/update: (See #3: Its analog
(blah2) has to be there for propn1 to match blah1, and if they match,
then since I do a recursive match test, propn2 must have matched blah2
as well, and they'll get a mapnode.)

3. If the other side of the argument propn (propn2) wasn't in the
recipient, then the propn it's an arg of (propn1) wouldn't be
isomorphic, so the propn1=blah1 mapnode wouldn't get added.  But this is
not a real issue.  Because if blah1 is there in the recipient, then its
arg blah2 would already be there as well. <-REALLY??  At least if #2 above is
correct.  That's what you'd need to get propn1 to match blah1 to produce
propn1=blah1, and make-constraint-net would cause a propn2=blah2 node to
be produced as well. 

4. [And questions like (b) above have clear answers.  If you send propn2
without propn1, then it's as if propn2 is a toplevel propn.  Nothing
about propnt1 matters.]

....................

SUMMARY OF POPCO BEHAVIOR AS APPLIED TO POPCO-X:

(A) Sending the propn should unmask that node in the propn net.  Argument
nodes should not be unmasked in the propn net.

(B) Whether or not any mapnodes should get unmasked depends on whether
the new propn matches any propns that are already there, using the
recursive match.  IN ORDER TO MATCH, ALL RECURSIVELY FOUND SUBARGS
MUST EXIST AS WELL, ON BOTH SIDES.  i.e. if the subargs of the added
propn don't exist, then don't match.  If the subargs on the other side
don't exist, don't match.
And IF IT MATCHES, THEN ITS ARGUMENTS MATCH ALL THE
WAY DOWN, AND THEIR MAPNODES SHOULD GET CREATED AS WELL.

.......
BUT: QUESTION: Is (A) really the desired behavior, even if it is what
POPCO did?

Pro: All that was sent was propn1.  OK, so the concepts of its args come
along with it, but that doesn't mean that they are seriously entertained
and thought about.  Why should a whole cluster of propns come over with one?

Con: If you understand propn1, you understand its args.  So they should
be realized as well.

	One man's modus ponens: Maybe you should not be able to
	communicate propn1 *unless* you already have propn2 (and so on
	all the way down, if propn2 is higher-order as well).  After
	all, you can't think that for which you have no concepts.
	That's why we teach concepts in classes.

	On the other hand, we in fact often teach concepts according to
	Frege's principle, in context, with examples, etc.  How do you
	learn a language?  It's not bottom up.

	Further, in POPCO there's no requirement that the predicates and
	objects already be present in the recipient.  This is a level of
	detail that we simply abstract from.  If we don't have that kind
	of test for predicates and objects, we shouldn't for arg propns
	either.

Turning around that last point: By acquiring propn1, you acquire its
non-propn components.  They come along for free.  This doesn't play any
role in the propn net, but note that it does affect the analogy net.
It's as if they're understood.  That suggests that arg propns should get
added to the propn net, just as they are allowed to compose mapnodes in
the analogy net.

On the other hand, it really is kind of feeling like you already have
a conceptual framework in the background, and communication really
is just adding salience to what you already could entertain.
Which could make sense either with or without adding arg propns
to the analogy net.
.......

-----------------

WHAT TO DO ABOUT THE QUESTION OF WHETHER TO ADD ARG-PROPNS TO PROPN NET?
I think I should have a switch, or use alternative functions.
I want to be able to run popco2 like popco, but it would be interesting
to consider the effect of adding the arg-propns too.

-----------------

Whether or not arg-propns should be added to the propn net as a result of
the top propn being communicated:

How about this strategy for determining whether to unmask mapnodes when
a propn is communicated:

1. Data structures:

A. Maintain clojmap A from propns in each analogue struct to propns to
which they can be mapped--i.e. to propns that participate in mapnodes in
the master list of mapnodes.  [DONE: propn-to-analogues field of AnalogyNet]

B. Maintain clojmap (or vec) B from propns to their arg-propns, arg-propns'
arg-propns, etc.  Or maybe to their propn net indexes.
[DONE: propn-to-family-propn-idxs in PropnNet]

2. Process:

When a propn P is sent to a receiver, look it up in clojmap A.
If there any propns Q are returned--i.e. there are possible mapnodes in which
P participates:
	check whether all of the recursively found family propns of
	the sent propn exist in the receiver.  If not, skip the rest.

	check whether the other sides have been unmasked in the receiver
	and if so:
		use clojmap B to look up the associated recursive arg-propns
		and check whether they've been unmasked in the receiver

		if all of these recursive arg-propns have been
		unmasked in the receiver
		then unmask the mapnode P=Q
		and all of its components, and then recurse on down.

So note that communication will require reference to:
	the propn net mask in the receiver
	the analogy net mask in the receiver
	global structures 
		(probably stored in the global analogy net stru)
		So all of these will need to be passed to
		communication functions
		well the masks will probably come from the person

*********
QUESTION: Suppose that I add a HO propn before its components exist,
so the mapnode isn't created.  Later, they are added.  What will cause
the mapnode to be created then?? Don't I have to therefore check
what HO propns propns participate in??

Yes.  One way to do that is this:
In addition to trying to add mapnodes for a sent propn
 in part by checking whether its extended-family propns exist
find out what HO propns it participates in
and do the same thing for them.

Question: Is there a simpler more elegant organization to these tasks?
i.e. for each extended family of propns in which a propn participates, see whether
all of the other members of the extended family exist, and if so,
check whether appropriate analogue nodes exist, and if so, create the mapnodes.

i.e. for the sent propn, you need to know whether its descendant propns exist.

But you also need to know, for those HO propns in which its a descendant, whether
the parent propn and all of its descendants exist.

In either case, you just need to know whether the other members of the set exist,
and it looks like it's exactly the same test.
Is that right?

OK, in particular, the idea would be:

For each propn p1, and for each propn p2 in which it participates
(including itself, i.e. p1), I need a collection of all propns in p2's
extended family.  And then in deciding what to add to the analogy net, I
have to first test, for each such p2, whether all of the propns in its
extended family exist.

This could be expensive if there were many propns and many HO propns.
Cries out for some kind of database interface or tricky algorithm in
that case.  Maybe the important thing is to put the tests behind
abstractions in functions.

Note that two such p2's might share a propn in their extended
families.  So it's then redundant to check that same propn twice.
Don't know how that could be handled.  Or whether/when it would be
worth it.

For each HO propn, there are at least two propns that reference it--more
if there are multiple propn args or multiple "generations" to the
family.

Maybe what I need is: for each propn, a list of lists of propns.
i.e. a map from propns to seqs of seqs of propns.
where each of the latter seqs contains all propns from a single
propn-extended-family, of which the key propn is a member.
